/***********************************************************************************************
  _______ ____   _____    __      _______            _____  _____  _______      ________ _____  
 |__   __/ __ \ / ____|   \ \    / / ____|   /\     |  __ \|  __ \|_   _\ \    / /  ____|  __ \ 
    | | | |  | | (___ _____\ \  / / |  __   /  \    | |  | | |__) | | |  \ \  / /| |__  | |__) |
    | | | |  | |\___ \______\ \/ /| | |_ | / /\ \   | |  | |  _  /  | |   \ \/ / |  __| |  _  / 
    | | | |__| |____) |      \  / | |__| |/ ____ \  | |__| | | \ \ _| |_   \  /  | |____| | \ \ 
    |_|  \____/|_____/        \/   \_____/_/    \_\ |_____/|_|  \_\_____|   \/   |______|_|  \_\
    
    AUTHOR: Chris Eckhardt
    DATE: 04/20/2020
    CLASS: CSC-720.01, Professor Arno Pruder
   
    CREDITS: This file uses code from multiple authors.
    See subroutine block comments for appropriate credit
    and reference urls.
    
    NOTE: Extra-credit not implemented. A maximum of 10 windows can be created.
	After 10 windows, the IPC messages for new windows will be received but ignored.
	The first 10 windows will still be able to receive and process IPC message commands.
 ***********************************************************************************************/

#include <vga.h>

/**************************************
*                 8X8 FONT            *
**************************************/
/*
	This ascii font rastor was found in a pdf on
	tr-dos archives. For full reference, see the 
	block comment for the write_regs function 
	below.
*/
static unsigned char g_8x8_font[2048] =
{
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x7E, 0x81, 0xA5, 0x81, 0xBD, 0x99, 0x81, 0x7E,
	0x7E, 0xFF, 0xDB, 0xFF, 0xC3, 0xE7, 0xFF, 0x7E,
	0x6C, 0xFE, 0xFE, 0xFE, 0x7C, 0x38, 0x10, 0x00,
	0x10, 0x38, 0x7C, 0xFE, 0x7C, 0x38, 0x10, 0x00,
	0x38, 0x7C, 0x38, 0xFE, 0xFE, 0x92, 0x10, 0x7C,
	0x00, 0x10, 0x38, 0x7C, 0xFE, 0x7C, 0x38, 0x7C,
	0x00, 0x00, 0x18, 0x3C, 0x3C, 0x18, 0x00, 0x00,
	0xFF, 0xFF, 0xE7, 0xC3, 0xC3, 0xE7, 0xFF, 0xFF,
	0x00, 0x3C, 0x66, 0x42, 0x42, 0x66, 0x3C, 0x00,
	0xFF, 0xC3, 0x99, 0xBD, 0xBD, 0x99, 0xC3, 0xFF,
	0x0F, 0x07, 0x0F, 0x7D, 0xCC, 0xCC, 0xCC, 0x78,
	0x3C, 0x66, 0x66, 0x66, 0x3C, 0x18, 0x7E, 0x18,
	0x3F, 0x33, 0x3F, 0x30, 0x30, 0x70, 0xF0, 0xE0,
	0x7F, 0x63, 0x7F, 0x63, 0x63, 0x67, 0xE6, 0xC0,
	0x99, 0x5A, 0x3C, 0xE7, 0xE7, 0x3C, 0x5A, 0x99,
	0x80, 0xE0, 0xF8, 0xFE, 0xF8, 0xE0, 0x80, 0x00,
	0x02, 0x0E, 0x3E, 0xFE, 0x3E, 0x0E, 0x02, 0x00,
	0x18, 0x3C, 0x7E, 0x18, 0x18, 0x7E, 0x3C, 0x18,
	0x66, 0x66, 0x66, 0x66, 0x66, 0x00, 0x66, 0x00,
	0x7F, 0xDB, 0xDB, 0x7B, 0x1B, 0x1B, 0x1B, 0x00,
	0x3E, 0x63, 0x38, 0x6C, 0x6C, 0x38, 0x86, 0xFC,
	0x00, 0x00, 0x00, 0x00, 0x7E, 0x7E, 0x7E, 0x00,
	0x18, 0x3C, 0x7E, 0x18, 0x7E, 0x3C, 0x18, 0xFF,
	0x18, 0x3C, 0x7E, 0x18, 0x18, 0x18, 0x18, 0x00,
	0x18, 0x18, 0x18, 0x18, 0x7E, 0x3C, 0x18, 0x00,
	0x00, 0x18, 0x0C, 0xFE, 0x0C, 0x18, 0x00, 0x00,
	0x00, 0x30, 0x60, 0xFE, 0x60, 0x30, 0x00, 0x00,
	0x00, 0x00, 0xC0, 0xC0, 0xC0, 0xFE, 0x00, 0x00,
	0x00, 0x24, 0x66, 0xFF, 0x66, 0x24, 0x00, 0x00,
	0x00, 0x18, 0x3C, 0x7E, 0xFF, 0xFF, 0x00, 0x00,
	0x00, 0xFF, 0xFF, 0x7E, 0x3C, 0x18, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x18, 0x3C, 0x3C, 0x18, 0x18, 0x00, 0x18, 0x00,
	0x6C, 0x6C, 0x6C, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x6C, 0x6C, 0xFE, 0x6C, 0xFE, 0x6C, 0x6C, 0x00,
	0x18, 0x7E, 0xC0, 0x7C, 0x06, 0xFC, 0x18, 0x00,
	0x00, 0xC6, 0xCC, 0x18, 0x30, 0x66, 0xC6, 0x00,
	0x38, 0x6C, 0x38, 0x76, 0xDC, 0xCC, 0x76, 0x00,
	0x30, 0x30, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x18, 0x30, 0x60, 0x60, 0x60, 0x30, 0x18, 0x00,
	0x60, 0x30, 0x18, 0x18, 0x18, 0x30, 0x60, 0x00,
	0x00, 0x66, 0x3C, 0xFF, 0x3C, 0x66, 0x00, 0x00,
	0x00, 0x18, 0x18, 0x7E, 0x18, 0x18, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x30,
	0x00, 0x00, 0x00, 0x7E, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x00,
	0x06, 0x0C, 0x18, 0x30, 0x60, 0xC0, 0x80, 0x00,
	0x7C, 0xCE, 0xDE, 0xF6, 0xE6, 0xC6, 0x7C, 0x00,
	0x30, 0x70, 0x30, 0x30, 0x30, 0x30, 0xFC, 0x00,
	0x78, 0xCC, 0x0C, 0x38, 0x60, 0xCC, 0xFC, 0x00,
	0x78, 0xCC, 0x0C, 0x38, 0x0C, 0xCC, 0x78, 0x00,
	0x1C, 0x3C, 0x6C, 0xCC, 0xFE, 0x0C, 0x1E, 0x00,
	0xFC, 0xC0, 0xF8, 0x0C, 0x0C, 0xCC, 0x78, 0x00,
	0x38, 0x60, 0xC0, 0xF8, 0xCC, 0xCC, 0x78, 0x00,
	0xFC, 0xCC, 0x0C, 0x18, 0x30, 0x30, 0x30, 0x00,
	0x78, 0xCC, 0xCC, 0x78, 0xCC, 0xCC, 0x78, 0x00,
	0x78, 0xCC, 0xCC, 0x7C, 0x0C, 0x18, 0x70, 0x00,
	0x00, 0x18, 0x18, 0x00, 0x00, 0x18, 0x18, 0x00,
	0x00, 0x18, 0x18, 0x00, 0x00, 0x18, 0x18, 0x30, 
	0x18, 0x30, 0x60, 0xC0, 0x60, 0x30, 0x18, 0x00,
	0x00, 0x00, 0x7E, 0x00, 0x7E, 0x00, 0x00, 0x00,
	0x60, 0x30, 0x18, 0x0C, 0x18, 0x30, 0x60, 0x00,
	0x3C, 0x66, 0x0C, 0x18, 0x18, 0x00, 0x18, 0x00,
	0x7C, 0xC6, 0xDE, 0xDE, 0xDC, 0xC0, 0x7C, 0x00,
	0x30, 0x78, 0xCC, 0xCC, 0xFC, 0xCC, 0xCC, 0x00,
	0xFC, 0x66, 0x66, 0x7C, 0x66, 0x66, 0xFC, 0x00,
	0x3C, 0x66, 0xC0, 0xC0, 0xC0, 0x66, 0x3C, 0x00,
	0xF8, 0x6C, 0x66, 0x66, 0x66, 0x6C, 0xF8, 0x00,
	0xFE, 0x62, 0x68, 0x78, 0x68, 0x62, 0xFE, 0x00,
	0xFE, 0x62, 0x68, 0x78, 0x68, 0x60, 0xF0, 0x00,
	0x3C, 0x66, 0xC0, 0xC0, 0xCE, 0x66, 0x3A, 0x00,
	0xCC, 0xCC, 0xCC, 0xFC, 0xCC, 0xCC, 0xCC, 0x00,
	0x78, 0x30, 0x30, 0x30, 0x30, 0x30, 0x78, 0x00,
	0x1E, 0x0C, 0x0C, 0x0C, 0xCC, 0xCC, 0x78, 0x00,
	0xE6, 0x66, 0x6C, 0x78, 0x6C, 0x66, 0xE6, 0x00,
	0xF0, 0x60, 0x60, 0x60, 0x62, 0x66, 0xFE, 0x00,
	0xC6, 0xEE, 0xFE, 0xFE, 0xD6, 0xC6, 0xC6, 0x00,
	0xC6, 0xE6, 0xF6, 0xDE, 0xCE, 0xC6, 0xC6, 0x00,
	0x38, 0x6C, 0xC6, 0xC6, 0xC6, 0x6C, 0x38, 0x00,
	0xFC, 0x66, 0x66, 0x7C, 0x60, 0x60, 0xF0, 0x00,
	0x7C, 0xC6, 0xC6, 0xC6, 0xD6, 0x7C, 0x0E, 0x00,
	0xFC, 0x66, 0x66, 0x7C, 0x6C, 0x66, 0xE6, 0x00,
	0x7C, 0xC6, 0xE0, 0x78, 0x0E, 0xC6, 0x7C, 0x00,
	0xFC, 0xB4, 0x30, 0x30, 0x30, 0x30, 0x78, 0x00,
	0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xFC, 0x00,
	0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x78, 0x30, 0x00,
	0xC6, 0xC6, 0xC6, 0xC6, 0xD6, 0xFE, 0x6C, 0x00,
	0xC6, 0xC6, 0x6C, 0x38, 0x6C, 0xC6, 0xC6, 0x00,
	0xCC, 0xCC, 0xCC, 0x78, 0x30, 0x30, 0x78, 0x00,
	0xFE, 0xC6, 0x8C, 0x18, 0x32, 0x66, 0xFE, 0x00,
	0x78, 0x60, 0x60, 0x60, 0x60, 0x60, 0x78, 0x00,
	0xC0, 0x60, 0x30, 0x18, 0x0C, 0x06, 0x02, 0x00,
	0x78, 0x18, 0x18, 0x18, 0x18, 0x18, 0x78, 0x00,
	0x10, 0x38, 0x6C, 0xC6, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF,
	0x30, 0x30, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x78, 0x0C, 0x7C, 0xCC, 0x76, 0x00,
	0xE0, 0x60, 0x60, 0x7C, 0x66, 0x66, 0xDC, 0x00,
	0x00, 0x00, 0x78, 0xCC, 0xC0, 0xCC, 0x78, 0x00,
	0x1C, 0x0C, 0x0C, 0x7C, 0xCC, 0xCC, 0x76, 0x00,
	0x00, 0x00, 0x78, 0xCC, 0xFC, 0xC0, 0x78, 0x00,
	0x38, 0x6C, 0x64, 0xF0, 0x60, 0x60, 0xF0, 0x00,
	0x00, 0x00, 0x76, 0xCC, 0xCC, 0x7C, 0x0C, 0xF8,
	0xE0, 0x60, 0x6C, 0x76, 0x66, 0x66, 0xE6, 0x00,
	0x30, 0x00, 0x70, 0x30, 0x30, 0x30, 0x78, 0x00,
	0x0C, 0x00, 0x1C, 0x0C, 0x0C, 0xCC, 0xCC, 0x78,
	0xE0, 0x60, 0x66, 0x6C, 0x78, 0x6C, 0xE6, 0x00,
	0x70, 0x30, 0x30, 0x30, 0x30, 0x30, 0x78, 0x00,
	0x00, 0x00, 0xCC, 0xFE, 0xFE, 0xD6, 0xD6, 0x00,
	0x00, 0x00, 0xB8, 0xCC, 0xCC, 0xCC, 0xCC, 0x00,
	0x00, 0x00, 0x78, 0xCC, 0xCC, 0xCC, 0x78, 0x00,
	0x00, 0x00, 0xDC, 0x66, 0x66, 0x7C, 0x60, 0xF0,
	0x00, 0x00, 0x76, 0xCC, 0xCC, 0x7C, 0x0C, 0x1E,
	0x00, 0x00, 0xDC, 0x76, 0x62, 0x60, 0xF0, 0x00,
	0x00, 0x00, 0x7C, 0xC0, 0x70, 0x1C, 0xF8, 0x00,
	0x10, 0x30, 0xFC, 0x30, 0x30, 0x34, 0x18, 0x00,
	0x00, 0x00, 0xCC, 0xCC, 0xCC, 0xCC, 0x76, 0x00,
	0x00, 0x00, 0xCC, 0xCC, 0xCC, 0x78, 0x30, 0x00,
	0x00, 0x00, 0xC6, 0xC6, 0xD6, 0xFE, 0x6C, 0x00,
	0x00, 0x00, 0xC6, 0x6C, 0x38, 0x6C, 0xC6, 0x00,
	0x00, 0x00, 0xCC, 0xCC, 0xCC, 0x7C, 0x0C, 0xF8,
	0x00, 0x00, 0xFC, 0x98, 0x30, 0x64, 0xFC, 0x00,
	0x1C, 0x30, 0x30, 0xE0, 0x30, 0x30, 0x1C, 0x00,
	0x18, 0x18, 0x18, 0x00, 0x18, 0x18, 0x18, 0x00,
	0xE0, 0x30, 0x30, 0x1C, 0x30, 0x30, 0xE0, 0x00,
	0x76, 0xDC, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x10, 0x38, 0x6C, 0xC6, 0xC6, 0xFE, 0x00,
	0x7C, 0xC6, 0xC0, 0xC6, 0x7C, 0x0C, 0x06, 0x7C,
	0x00, 0xCC, 0x00, 0xCC, 0xCC, 0xCC, 0x76, 0x00,
	0x1C, 0x00, 0x78, 0xCC, 0xFC, 0xC0, 0x78, 0x00,
	0x7E, 0x81, 0x3C, 0x06, 0x3E, 0x66, 0x3B, 0x00,
	0xCC, 0x00, 0x78, 0x0C, 0x7C, 0xCC, 0x76, 0x00,
	0xE0, 0x00, 0x78, 0x0C, 0x7C, 0xCC, 0x76, 0x00,
	0x30, 0x30, 0x78, 0x0C, 0x7C, 0xCC, 0x76, 0x00,
	0x00, 0x00, 0x7C, 0xC6, 0xC0, 0x78, 0x0C, 0x38,
	0x7E, 0x81, 0x3C, 0x66, 0x7E, 0x60, 0x3C, 0x00,
	0xCC, 0x00, 0x78, 0xCC, 0xFC, 0xC0, 0x78, 0x00,
	0xE0, 0x00, 0x78, 0xCC, 0xFC, 0xC0, 0x78, 0x00,
	0xCC, 0x00, 0x70, 0x30, 0x30, 0x30, 0x78, 0x00,
	0x7C, 0x82, 0x38, 0x18, 0x18, 0x18, 0x3C, 0x00,
	0xE0, 0x00, 0x70, 0x30, 0x30, 0x30, 0x78, 0x00,
	0xC6, 0x10, 0x7C, 0xC6, 0xFE, 0xC6, 0xC6, 0x00,
	0x30, 0x30, 0x00, 0x78, 0xCC, 0xFC, 0xCC, 0x00,
	0x1C, 0x00, 0xFC, 0x60, 0x78, 0x60, 0xFC, 0x00,
	0x00, 0x00, 0x7F, 0x0C, 0x7F, 0xCC, 0x7F, 0x00,
	0x3E, 0x6C, 0xCC, 0xFE, 0xCC, 0xCC, 0xCE, 0x00,
	0x78, 0x84, 0x00, 0x78, 0xCC, 0xCC, 0x78, 0x00,
	0x00, 0xCC, 0x00, 0x78, 0xCC, 0xCC, 0x78, 0x00,
	0x00, 0xE0, 0x00, 0x78, 0xCC, 0xCC, 0x78, 0x00,
	0x78, 0x84, 0x00, 0xCC, 0xCC, 0xCC, 0x76, 0x00,
	0x00, 0xE0, 0x00, 0xCC, 0xCC, 0xCC, 0x76, 0x00,
	0x00, 0xCC, 0x00, 0xCC, 0xCC, 0x7C, 0x0C, 0xF8,
	0xC3, 0x18, 0x3C, 0x66, 0x66, 0x3C, 0x18, 0x00,
	0xCC, 0x00, 0xCC, 0xCC, 0xCC, 0xCC, 0x78, 0x00,
	0x18, 0x18, 0x7E, 0xC0, 0xC0, 0x7E, 0x18, 0x18,
	0x38, 0x6C, 0x64, 0xF0, 0x60, 0xE6, 0xFC, 0x00,
	0xCC, 0xCC, 0x78, 0x30, 0xFC, 0x30, 0xFC, 0x30,
	0xF8, 0xCC, 0xCC, 0xFA, 0xC6, 0xCF, 0xC6, 0xC3,
	0x0E, 0x1B, 0x18, 0x3C, 0x18, 0x18, 0xD8, 0x70,
	0x1C, 0x00, 0x78, 0x0C, 0x7C, 0xCC, 0x76, 0x00,
	0x38, 0x00, 0x70, 0x30, 0x30, 0x30, 0x78, 0x00,
	0x00, 0x1C, 0x00, 0x78, 0xCC, 0xCC, 0x78, 0x00,
	0x00, 0x1C, 0x00, 0xCC, 0xCC, 0xCC, 0x76, 0x00,
	0x00, 0xF8, 0x00, 0xB8, 0xCC, 0xCC, 0xCC, 0x00,
	0xFC, 0x00, 0xCC, 0xEC, 0xFC, 0xDC, 0xCC, 0x00,
	0x3C, 0x6C, 0x6C, 0x3E, 0x00, 0x7E, 0x00, 0x00,
	0x38, 0x6C, 0x6C, 0x38, 0x00, 0x7C, 0x00, 0x00,
	0x18, 0x00, 0x18, 0x18, 0x30, 0x66, 0x3C, 0x00,
	0x00, 0x00, 0x00, 0xFC, 0xC0, 0xC0, 0x00, 0x00,
	0x00, 0x00, 0x00, 0xFC, 0x0C, 0x0C, 0x00, 0x00,
	0xC6, 0xCC, 0xD8, 0x36, 0x6B, 0xC2, 0x84, 0x0F,
	0xC3, 0xC6, 0xCC, 0xDB, 0x37, 0x6D, 0xCF, 0x03,
	0x18, 0x00, 0x18, 0x18, 0x3C, 0x3C, 0x18, 0x00,
	0x00, 0x33, 0x66, 0xCC, 0x66, 0x33, 0x00, 0x00,
	0x00, 0xCC, 0x66, 0x33, 0x66, 0xCC, 0x00, 0x00,
	0x22, 0x88, 0x22, 0x88, 0x22, 0x88, 0x22, 0x88,
	0x55, 0xAA, 0x55, 0xAA, 0x55, 0xAA, 0x55, 0xAA,
	0xDB, 0xF6, 0xDB, 0x6F, 0xDB, 0x7E, 0xD7, 0xED,
	0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18,
	0x18, 0x18, 0x18, 0x18, 0xF8, 0x18, 0x18, 0x18,
	0x18, 0x18, 0xF8, 0x18, 0xF8, 0x18, 0x18, 0x18,
	0x36, 0x36, 0x36, 0x36, 0xF6, 0x36, 0x36, 0x36,
	0x00, 0x00, 0x00, 0x00, 0xFE, 0x36, 0x36, 0x36,
	0x00, 0x00, 0xF8, 0x18, 0xF8, 0x18, 0x18, 0x18,
	0x36, 0x36, 0xF6, 0x06, 0xF6, 0x36, 0x36, 0x36,
	0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,
	0x00, 0x00, 0xFE, 0x06, 0xF6, 0x36, 0x36, 0x36,
	0x36, 0x36, 0xF6, 0x06, 0xFE, 0x00, 0x00, 0x00,
	0x36, 0x36, 0x36, 0x36, 0xFE, 0x00, 0x00, 0x00,
	0x18, 0x18, 0xF8, 0x18, 0xF8, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0xF8, 0x18, 0x18, 0x18,
	0x18, 0x18, 0x18, 0x18, 0x1F, 0x00, 0x00, 0x00,
	0x18, 0x18, 0x18, 0x18, 0xFF, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0xFF, 0x18, 0x18, 0x18,
	0x18, 0x18, 0x18, 0x18, 0x1F, 0x18, 0x18, 0x18, 
	0x00, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00,
	0x18, 0x18, 0x18, 0x18, 0xFF, 0x18, 0x18, 0x18,
	0x18, 0x18, 0x1F, 0x18, 0x1F, 0x18, 0x18, 0x18,
	0x36, 0x36, 0x36, 0x36, 0x37, 0x36, 0x36, 0x36,
	0x36, 0x36, 0x37, 0x30, 0x3F, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x3F, 0x30, 0x37, 0x36, 0x36, 0x36,
	0x36, 0x36, 0xF7, 0x00, 0xFF, 0x00, 0x00, 0x00,
	0x00, 0x00, 0xFF, 0x00, 0xF7, 0x36, 0x36, 0x36,
	0x36, 0x36, 0x37, 0x30, 0x37, 0x36, 0x36, 0x36,
	0x00, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0x00, 0x00,
	0x36, 0x36, 0xF7, 0x00, 0xF7, 0x36, 0x36, 0x36,
	0x18, 0x18, 0xFF, 0x00, 0xFF, 0x00, 0x00, 0x00,
	0x36, 0x36, 0x36, 0x36, 0xFF, 0x00, 0x00, 0x00,
	0x00, 0x00, 0xFF, 0x00, 0xFF, 0x18, 0x18, 0x18,
	0x00, 0x00, 0x00, 0x00, 0xFF, 0x36, 0x36, 0x36,
	0x36, 0x36, 0x36, 0x36, 0x3F, 0x00, 0x00, 0x00,
	0x18, 0x18, 0x1F, 0x18, 0x1F, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x1F, 0x18, 0x1F, 0x18, 0x18, 0x18,
	0x00, 0x00, 0x00, 0x00, 0x3F, 0x36, 0x36, 0x36,
	0x36, 0x36, 0x36, 0x36, 0xFF, 0x36, 0x36, 0x36,
	0x18, 0x18, 0xFF, 0x18, 0xFF, 0x18, 0x18, 0x18,
	0x18, 0x18, 0x18, 0x18, 0xF8, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x1F, 0x18, 0x18, 0x18,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF,
	0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0,
	0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F,
	0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x76, 0xDC, 0xC8, 0xDC, 0x76, 0x00,
	0x00, 0x78, 0xCC, 0xF8, 0xCC, 0xF8, 0xC0, 0xC0,
	0x00, 0xFC, 0xCC, 0xC0, 0xC0, 0xC0, 0xC0, 0x00,
	0x00, 0x00, 0xFE, 0x6C, 0x6C, 0x6C, 0x6C, 0x00,
	0xFC, 0xCC, 0x60, 0x30, 0x60, 0xCC, 0xFC, 0x00,
	0x00, 0x00, 0x7E, 0xD8, 0xD8, 0xD8, 0x70, 0x00,
	0x00, 0x66, 0x66, 0x66, 0x66, 0x7C, 0x60, 0xC0,
	0x00, 0x76, 0xDC, 0x18, 0x18, 0x18, 0x18, 0x00,
	0xFC, 0x30, 0x78, 0xCC, 0xCC, 0x78, 0x30, 0xFC,
	0x38, 0x6C, 0xC6, 0xFE, 0xC6, 0x6C, 0x38, 0x00,
	0x38, 0x6C, 0xC6, 0xC6, 0x6C, 0x6C, 0xEE, 0x00,
	0x1C, 0x30, 0x18, 0x7C, 0xCC, 0xCC, 0x78, 0x00,
	0x00, 0x00, 0x7E, 0xDB, 0xDB, 0x7E, 0x00, 0x00,
	0x06, 0x0C, 0x7E, 0xDB, 0xDB, 0x7E, 0x60, 0xC0,
	0x38, 0x60, 0xC0, 0xF8, 0xC0, 0x60, 0x38, 0x00,
	0x78, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x00,
	0x00, 0x7E, 0x00, 0x7E, 0x00, 0x7E, 0x00, 0x00,
	0x18, 0x18, 0x7E, 0x18, 0x18, 0x00, 0x7E, 0x00,
	0x60, 0x30, 0x18, 0x30, 0x60, 0x00, 0xFC, 0x00,
	0x18, 0x30, 0x60, 0x30, 0x18, 0x00, 0xFC, 0x00,
	0x0E, 0x1B, 0x1B, 0x18, 0x18, 0x18, 0x18, 0x18,
	0x18, 0x18, 0x18, 0x18, 0x18, 0xD8, 0xD8, 0x70,
	0x18, 0x18, 0x00, 0x7E, 0x00, 0x18, 0x18, 0x00,
	0x00, 0x76, 0xDC, 0x00, 0x76, 0xDC, 0x00, 0x00,
	0x38, 0x6C, 0x6C, 0x38, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x18, 0x18, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x18, 0x00, 0x00, 0x00,
	0x0F, 0x0C, 0x0C, 0x0C, 0xEC, 0x6C, 0x3C, 0x1C,
	0x58, 0x6C, 0x6C, 0x6C, 0x6C, 0x00, 0x00, 0x00,
	0x70, 0x98, 0x30, 0x60, 0xF8, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x3C, 0x3C, 0x3C, 0x3C, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

/* FONT SIZE IS 8x8 */
#define FONT_SIZE           	8

/* designated base vga memory address */
#define VIDEO_BASE_ADDRESS  	0xA0000

/* screen dimentions (320x200, color 256) */
#define SCREEN_WIDTH        	320  
#define SCREEN_HEIGHT       	200

/* values to be written to vga registers */
#define VGA_AC_INDEX       	0x3C0
#define VGA_AC_WRITE        	0x3C0
#define VGA_AC_READ         	0x3C1
#define VGA_MISC_WRITE      	0x3C2
#define VGA_SEQ_INDEX       	0x3C4
#define VGA_SEQ_DATA        	0x3C5
#define VGA_DAC_READ_INDEX  	0x3C7
#define VGA_DAC_WRITE_INDEX 	0x3C8
#define VGA_DAC_DATA        	0x3C9
#define VGA_MISC_READ       	0x3CC
#define VGA_GC_INDEX        	0x3CE
#define VGA_GC_DATA         	0x3CF
#define VGA_CRTC_INDEX      	0x3D4       
#define VGA_CRTC_DATA       	0x3D5
#define VGA_INSTAT_READ     	0x3DA

/* used for indexing VGA REGISTERS*/
#define VGA_NUM_SEQ_REGS    	5
#define VGA_NUM_CRTC_REGS   	25
#define VGA_NUM_GC_REGS     	9
#define VGA_NUM_AC_REGS     	21
#define VGA_NUM_REGS        	(1 + VGA_NUM_SEQ_REGS + VGA_NUM_CRTC_REGS + \
				VGA_NUM_GC_REGS + VGA_NUM_AC_REGS)

/* commonly used colors */
#define BLACK 			0x00
#define WHITE 			0x3F

/* constants used for window management */
#define MAX_WINDOWS		10
#define NO_WINDOW		-1

#define CANVAS			2
#define FRAME			1
#define OUT_BOUNDS		0

/* window management structures and IPC port */
unsigned int g_window_id 	= 0;

typedef struct {
	const char * 	title;
    	int 		x;
    	int		y;
    	int		width;
    	int		height;
    	int		frame_x;
   	int		frame_y;
    	int		frame_width;
    	int		frame_height;
    	unsigned int	window_id;
} window;

window windows[MAX_WINDOWS];

PORT vga_port;

/***************************************************************
 *                     Function Prototypes                     *
 ***************************************************************/

void    vga_process     ();

void    create_window   ( PARAM_VGA_CREATE_WINDOW * params );

void	draw_pixel      ( PARAM_VGA_DRAW_PIXEL * params );

void	draw_text       ( PARAM_VGA_DRAW_TEXT * params );

void 	draw_line       ( PARAM_VGA_DRAW_LINE * params );

void    write_regs      ( unsigned char * regs );

void    draw_frame      ( window * wnd );

void 	clear_screen 	();

void 	fill_rect       ( int x, int y, int width, int height, int color );

void 	set_pixel       ( window * wnd, int x, int y, int color , int bounds);

void 	draw_string 	( window * wnd, int x, int y, int bg_color, int fg_color, const char * str, int in_bounds );

void 	draw_character 	( window * wnd, int x, int y, int bg_color, int fg_color, char c, int in_bounds );

int 	clip_check      ( int x, int y, int width, int height);

int 	m_abs           ( int a );


/***************************************************************
 *                          INIT VGA                           *
 ***************************************************************/
/* 
	this is the initializer subroutine. It first writes to the VGA 
	registers to initialize graphics mode (in this case 320x200x256 VGA 
	mode). It then creates the graphics driver process and assigns the 
	IPC port to facilitate client process requests. The Screen is then 
	cleared (this is because when VGA mode is started, there is junk in 
	the screen's section of ram). An integer value of 1 is returned to 
	signal kernal_main that graphics mode has been enabled.
*/

int init_vga()
{

    unsigned char g_320x200x256[] =
    {
        /* MISC */
        0x63,
        /* SEQ */
        0x03, 0x01, 0x0F, 0x00, 0x0E,
        /* CRTC */
        0x5F, 0x4F, 0x50, 0x82, 0x54, 0x80, 0xBF, 0x1F,
        0x00, 0x41, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x9C, 0x0E, 0x8F, 0x28, 0x40, 0x96, 0xB9, 0xA3,
        0xFF,
        /* GC */
        0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x05, 0x0F,
        0xFF,
        /* AC */
        0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
        0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,
        0x41, 0x00, 0x0F, 0x00, 0x00
    };

    /* set to vga 256 color mode */
    write_regs(g_320x200x256);

    /* create vga driver process */
    vga_port = create_process(vga_process, 7, 0, "VGA");

    /* get rid of junk in memory */
    clear_screen();

    /* ret */
    return 1;
}

/********************************************************************************
 *                              VGA DEVICE DRIVER                               *
 * *****************************************************************************/
/*
	This is the actual VGA device driver process. This process is first created in init_vga().
	This process waits for IPC messages from client processes, processes the messages, and then 
	loops back to repeat this process.
*/

void vga_process (PROCESS proc, PARAM param)
{

    VGA_WINDOW_MSG * msg;
    PROCESS sender;

    /* wait for messages */
    while (1)
    {
        
        /* get message from sending process */
        msg = (VGA_WINDOW_MSG *) receive(&sender);

        /* process request from message */
        switch (msg->cmd) 
        {

            case VGA_CREATE_WINDOW:
                create_window( (PARAM_VGA_CREATE_WINDOW *) &msg->u.create_window );
                break;

            case VGA_DRAW_TEXT:
                draw_text( (PARAM_VGA_DRAW_TEXT *) &msg->u.draw_text );
                break;

            case VGA_DRAW_PIXEL:
                draw_pixel( (PARAM_VGA_DRAW_PIXEL *) &msg->u.draw_pixel );
                break;

            case VGA_DRAW_LINE:
                draw_line( (PARAM_VGA_DRAW_LINE *) &msg->u.draw_line );
                break;
        }

        /* reply to sender */
        reply(sender);
    }
}

/**************************************************************
 *               WRITE TO THE VGA REGISTERS                   *
 *************************************************************/
/*
	NOTE: This code is not my own. It was taken a pdf about VGA programming in 
	the TR-DOS archives (https://singlix.com/trdos/).

	AUTHOR: Origional Author not listed in PDF. I would like to give them 
	credit but have been unable to find a name.

	REFERENCE: https://www.singlix.com/trdos/archive/vga/Graphics%20in%20pmode.pdf
*/

void write_regs (unsigned char *regs)
{
    unsigned int i;

    /* write MISCELLANEOUS reg */
    outportb (VGA_MISC_WRITE, *(regs++));
    
    /* write SEQUENCER regs */
    for (i = 0; i < VGA_NUM_SEQ_REGS; i++)
    {
        outportb (VGA_SEQ_INDEX, i);
        outportb (VGA_SEQ_DATA, *(regs++));
    }

    /* unlock CRTC registers */
    outportb (VGA_CRTC_INDEX, 0x03);
    outportb (VGA_CRTC_DATA, inportb (VGA_CRTC_DATA) | 0x80);
    outportb (VGA_CRTC_INDEX, 0x11);
    outportb (VGA_CRTC_DATA, inportb (VGA_CRTC_DATA) & ~0x80);

    /* make sure they remain unlocked */
    regs[0x03] |= 0x80;
    regs[0x11] &= ~0x80;

    /* write CRTC regs */
    for (i = 0; i < VGA_NUM_CRTC_REGS; i++)
    {
        outportb (VGA_CRTC_INDEX, i);
        outportb (VGA_CRTC_DATA, *(regs++));
    }

    /* write GRAPHICS CONTROLLER regs */
    for (i = 0; i < VGA_NUM_GC_REGS; i++)
    {
        outportb (VGA_GC_INDEX, i);
        outportb (VGA_GC_DATA, *(regs++));
    }

    /* write ATTRIBUTE CONTROLLER regs */
    for (i = 0; i < VGA_NUM_AC_REGS; i++)
    {
        (void) inportb (VGA_INSTAT_READ);
        outportb (VGA_AC_INDEX, i);
        outportb (VGA_AC_WRITE, *(regs++));
    }

    /* lock 16-color palette and unblank display */
    (void) inportb (VGA_INSTAT_READ);
    outportb (VGA_AC_INDEX, 0x20);
}

/***************************************************************
 *                       Create Window                         *
 ***************************************************************/

void create_window ( PARAM_VGA_CREATE_WINDOW * params) 
{
	/* declare frame attributes */
	int frame_x, frame_y, frame_w, frame_h;

	/* calculate frame size */
	frame_x = params->x-1;
	frame_y = params->y-10;
	frame_w = params->width+2;
	frame_h = params->height+11;

	/* check for frame clipping */
	if (frame_x < 0) {
		frame_x = 0;
		params->x = 1;
	}
	if (frame_y < 0) {
		frame_y = 0;
		params->y = 10;
	}
	if (frame_x+frame_w >= SCREEN_WIDTH) {
		frame_x = SCREEN_WIDTH-frame_w;
		params->x = SCREEN_WIDTH-frame_w+1;
	}
	if (frame_y+frame_h >= SCREEN_HEIGHT) {
		frame_y = SCREEN_HEIGHT-frame_h;
		params->y = SCREEN_HEIGHT-frame_h+10;
	}

	/* Assign window id number */
	if (g_window_id >= MAX_WINDOWS) {
		/* NO MORE WINDOWS LEFT */
		params->window_id = NO_WINDOW;
		return;
	}

	params->window_id = g_window_id++;

	/* add to window array */
	window * new_window			= &windows[params->window_id];
	new_window->title			= params->title;
	new_window->x				= params->x;
	new_window->y				= params->y;
	new_window->width			= params->width;
	new_window->height			= params->height;
	new_window->frame_y			= frame_y;
	new_window->frame_x			= frame_x;
	new_window->frame_height 		= frame_h;
	new_window->frame_width			= frame_w;
	new_window->window_id			= params->window_id;

	/* render the actual window */
	draw_frame(new_window);

}

/*************************************************
 *                  DRAW PIXEL                   *
 * **********************************************/

void draw_pixel (PARAM_VGA_DRAW_PIXEL * params)
{

	if (params->window_id == NO_WINDOW)
		return;

	window * wnd = &windows[params->window_id];

	/* draw pixel */
	set_pixel(wnd, params->x, params->y, params->color, CANVAS);
}

/*************************************************
 *                   DRAW LINE                   *
 * **********************************************/

/*
	NOTE: This code was based on pseudo code from a tutorial at 
	freecodecamp.org. It is based on Bresenhamâ€™s algorithm
	for drawing lines.

	AUTHOR: goes by Javascript Teacher, actual name is unknown

	REFERENCE: https://www.freecodecamp.org/news/how-to-code-your-first-algorithm-draw-a-line-ca121f9a1395/
*/

void draw_line (PARAM_VGA_DRAW_LINE * params) 
{

	if (params->window_id == NO_WINDOW)
		return;

	window * wnd = &windows[params->window_id];

	int x, y, dx, dy, dx1, dy1, px, py, xe, ye, i;

	dx = params->x1 - params->x0;
	dy = params->y1 - params->y0;

	dx1 = m_abs(dx);
	dy1 = m_abs(dy);

	px = 2 * dy1 - dx1;
	py = 2 * dx1 - dy1;

	if (dy1 <= dx1) {

		if (dx >= 0) {
			x = params->x0;
			y = params->y0;
			xe = params->x1;
		} else {
			x = params->x1;
			y = params->y1;
			xe = params->x0;
		}

		set_pixel(wnd, x, y, params->color, CANVAS);

		for (i = 0; x < xe; i++) {
			x += 1;

			if (px < 0) {
				px = px + 2 * dy1;
			} else {
				if ((dx < 0 && dy < 0) || (dx > 0 && dy > 0)) {
					y += 1;
				} else {
					y -= 1;
				}
				px = px + 2 * (dy1 - dx1);
			}

			set_pixel(wnd, x, y, params->color, CANVAS);
		}

	} else {

		if (dy >= 0) {
			x = params->x0;
			y = params->y0;
			ye = params->y1;
		} else {
			x = params->x1;
			y = params->y1;
			ye = params->y0;
		}

		set_pixel(wnd, x, y, params->color, CANVAS);

		for (i = 0; y < ye; i++) {
			y += 1;

			if (py < 0) {
				py = py + 2 * dx1;
			} else {
				if ((dx < 0 && dy < 0) || (dx > 0 && dy > 0)) {
					x += 1;
				} else {
					x -= 1;
				}
				py = py + 2 * (dx1 - dy1);
			}

            		set_pixel(wnd, x, y, params->color, CANVAS);
			
		}

	}
}

/*************************************************
 *                   DRAW TEXT                   *
 * **********************************************/

void draw_text (PARAM_VGA_DRAW_TEXT * params) 
{
	if (params->window_id == NO_WINDOW)
		return;

	window * wnd = &windows[params->window_id];

	/* print string */
	draw_string(wnd, params->x, params->y, params->bg_color, params->fg_color, params->text, CANVAS);
}


/****************************************************************
 *                       HELPER FUNCTIONS                       *
 ***************************************************************/
/*
	These are helper functions to do most of the work. These functions can't
	be directly called by the user, they are just called by the IPC API (create_window, 
	draw_text, draw_pixel, draw_line) to divide labor between functions and simplify 
	the code.
*/

void draw_frame (window * wnd) 
{
	/* render window */
	fill_rect(wnd->frame_x, wnd->frame_y, wnd->frame_width, wnd->frame_height, WHITE);
	fill_rect(wnd->x, wnd->y, wnd->width, wnd->height, BLACK);
	/* write title on frame */
	draw_string( wnd, (wnd->frame_width/2)-((k_strlen(wnd->title)/2)*8), 2, WHITE, BLACK, wnd->title, FRAME);
}

void clear_screen () { fill_rect(0, 0, SCREEN_WIDTH, SCREEN_HEIGHT, BLACK); }

void fill_rect (int x, int y, int width, int height, int color)
{
	int x2, y2;
	for(x2 = x; x2 < x + width; x2++)
		for(y2 = y; y2 < y + height; y2++)
			poke_pixel(x2, y2, color);
}

void set_pixel (window * wnd, int x, int y, int color, int bounds) 
{
    switch (bounds)
	{
		case CANVAS:
			if (clip_check (x, y, wnd->width, wnd->height))
            			poke_pixel (wnd->x+x, wnd->y+y, color);
			break;

		case FRAME:
			if (clip_check (x, y, wnd->frame_width, wnd->frame_height))
            			poke_pixel (wnd->frame_x+x, wnd->frame_y+y, color);
			break;

		case OUT_BOUNDS:
			if (clip_check (x, y, SCREEN_WIDTH, SCREEN_HEIGHT))
				poke_pixel (x, y, color);  
			break;
	}
}

void poke_pixel (int x, int y, int color) 
{
	poke_b( (VIDEO_BASE_ADDRESS + y * SCREEN_WIDTH + x), color);
}

void draw_string (window * wnd, int x, int y, int bg_color, int fg_color, const char * str, int bounds) {

	while (*(str) != '\0') {
		draw_character(wnd, x, y, bg_color, fg_color, *(str), bounds);
		str++;
		x+=8;
	}
}

void draw_character (window * wnd, int x, int y, int bg_color, int fg_color, char c, int bounds) {

	int i, n;
	unsigned char b;

	for (i = 0; i < FONT_SIZE; i++) {

		b = g_8x8_font[(((int)c)*FONT_SIZE)+i];

		for (n = 0; n < FONT_SIZE; n++) {

			if ((b>>n&1)) {
				set_pixel(wnd, x+FONT_SIZE-n-1, y+i, fg_color, bounds);
			} else {
				set_pixel(wnd, x+FONT_SIZE-n-1, y+i, bg_color, bounds);
			}
		}
	}
}

int clip_check (int x, int y, int width, int height)
{

	if (x < 0)
		return 0;

	if (x >= width)
		return 0;

	if (y < 0)
		return 0;

	if (y >= height)
		return 0;

	return 1;

}

int m_abs (int a) {
	return a < 0 ? -a : a;
}









/*********************************************************
 *                      TEST PROCESS                     *
 *********************************************************/
/* 
	I'm declaring this in vga.h just under init_vga().
	Then I added the following function call in kernel_main,
	just after the init_vga() 'if' statement.

	create_process (vga_test, 5, NULL, "VGA TEST");
 */

void vga_test (PROCESS proc, PARAM param)
{
	VGA_WINDOW_MSG msg;

	// Create Window 1
	msg.cmd = VGA_CREATE_WINDOW;
	msg.u.create_window.title = "Window 1";
	msg.u.create_window.x = 50;
	msg.u.create_window.y = 50;
	msg.u.create_window.width = 100;
	msg.u.create_window.height = 50;
	send(vga_port, &msg);
	unsigned int window1_id = msg.u.create_window.window_id;

	// Create Window 2
	msg.cmd = VGA_CREATE_WINDOW;
	msg.u.create_window.title = "Window 2";
	msg.u.create_window.x = 10;
	msg.u.create_window.y = 120;
	msg.u.create_window.width = 150;
	msg.u.create_window.height = 60;
	send(vga_port, &msg);
	unsigned int window2_id = msg.u.create_window.window_id;

	// Create Window 3
	msg.cmd = VGA_CREATE_WINDOW;
	msg.u.create_window.title = "Window 3";
	msg.u.create_window.x = 180;
	msg.u.create_window.y = 30;
	msg.u.create_window.width = 100;
	msg.u.create_window.height = 100;
	send(vga_port, &msg);
	unsigned int window3_id = msg.u.create_window.window_id;

	// Draw some lines in Window 1
	char current_color = 0;
	for (int x = 0; x < 100; x += 2) {
		msg.cmd = VGA_DRAW_LINE;
		msg.u.draw_line.window_id = window1_id;
		msg.u.draw_line.x0 = x;
		msg.u.draw_line.y0 = 0;
		msg.u.draw_line.x1 = 100 - x;
		msg.u.draw_line.y1 = 49;
		msg.u.draw_line.color = current_color++;
		send(vga_port, &msg);
	}

	// Write some text in Window 2
	msg.cmd = VGA_DRAW_TEXT;
	msg.u.draw_text.window_id = window2_id;
	msg.u.draw_text.text = "Hello CSC720!";
	msg.u.draw_text.x = 1;
	msg.u.draw_text.y = 1;
	msg.u.draw_text.fg_color = 0x3f; // White
	msg.u.draw_text.bg_color = 0;
	send(vga_port, &msg);

	// Write some text in Window 2 that will be clipped
	msg.cmd = VGA_DRAW_TEXT;
	msg.u.draw_text.window_id = window2_id;
	msg.u.draw_text.text = "Text that is too long will be clipped";
	msg.u.draw_text.x = 20;
	msg.u.draw_text.y = 20;
	msg.u.draw_text.fg_color = 0x3f; // White
	msg.u.draw_text.bg_color = 0;
	send(vga_port, &msg);

	// Draw some random pixels in Window 3
	msg.cmd = VGA_DRAW_PIXEL;
	msg.u.draw_pixel.window_id = window3_id;
	current_color = 0;
	for (int x = 3; x < 100; x += 5) {
		for (int y = 3; y < 100; y += 5) {
		msg.u.draw_pixel.x = x;
		msg.u.draw_pixel.y = y;
		msg.u.draw_pixel.color = current_color;
		current_color = (current_color + 1) % 64;
		send(vga_port, &msg);
		}
	}
}
